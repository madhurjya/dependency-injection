{"version":3,"sources":["../src/dependency.js"],"names":["_registrations","Map","DependencyContainer","registrationName","has","name","set","DependencyMapping","get","mappingName","Error","dependencyMapping","_mappings","dependencyDetails","_resolve","func","isFunction","TypeError","funcArguments","getFunctionParameters","map","resolve","param","type","DependencyDetails","_type","_resolveWithConstructor","_constructorParameterMapper","_resolvePropertyValues","_propertyValueMapper","_isInSingletonScope","_resolvedInstance","parameterMapperFunc","ParameterMapper","propertyValueMapperFunc","PropertyMapper","constructorArguments","forEach","value","parameterNames","_parameterMap","ParameterDetails","values","_propertyMap","entries","prop","parameterName","_name","_resolveAsValue","_valueToResolve","_resolveAsDependency","_registrationNameToResolve","_mappingNameToResolve","valueToResolve","paramExtract","toString","match","length","split","replace","trim"],"mappings":"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","file":"dependency.js","sourcesContent":["const _registrations = new Map();\r\n\r\nclass DependencyContainer {\r\n    static isRegistered(registrationName) {\r\n        return _registrations.has(registrationName);\r\n    }\r\n    static register(name) {\r\n        if (!_registrations.has(name)) {\r\n            _registrations.set(name, new DependencyMapping());\r\n        }\r\n        return _registrations.get(name);\r\n    }\r\n    static resolve(registrationName, mappingName) {\r\n        if (!_registrations.has(registrationName)) {\r\n            throw new Error(`${registrationName} is not registered.`);\r\n        }\r\n        const dependencyMapping = _registrations.get(registrationName);\r\n        if (!dependencyMapping._mappings.has(mappingName)) {\r\n            throw new Error(`Mapping ${mappingName} is not registered.`);\r\n        }\r\n        const dependencyDetails = dependencyMapping._mappings.get(mappingName);\r\n        return dependencyDetails._resolve();\r\n    }\r\n    static inject(func) {\r\n        if (!isFunction(func)) {\r\n            throw new TypeError('Must be a function of class');\r\n        }\r\n        const funcArguments = getFunctionParameters(func)\r\n            .map(param => {\r\n                return DependencyContainer.resolve(param);\r\n            });\r\n        return func(...funcArguments);\r\n    }\r\n}\r\n\r\nclass DependencyMapping {\r\n    constructor() {\r\n        this._mappings = new Map();\r\n    }\r\n    asType(type, mappingName) {\r\n        if (this._mappings.has(mappingName)) {\r\n            throw new Error(`${mappingName || 'default'} mapping is already registered.`);\r\n        }\r\n        const dependencyDetails = new DependencyDetails(type);\r\n        this._mappings.set(mappingName, dependencyDetails);\r\n        return dependencyDetails;\r\n    }\r\n}\r\n\r\nclass DependencyDetails {\r\n    constructor(type) {\r\n        this._type = type;\r\n        this._resolveWithConstructor = false;\r\n        this._constructorParameterMapper = null;\r\n        this._resolvePropertyValues = false;\r\n        this._propertyValueMapper = false;\r\n        this._isInSingletonScope = false;\r\n        this._resolvedInstance = null;\r\n    }\r\n    withConstructor(parameterMapperFunc) {\r\n        if (this._resolveWithConstructor === true) {\r\n            throw new Error('Constructor is already configured.');\r\n        }\r\n        this._resolveWithConstructor = true;\r\n        this._constructorParameterMapper = new ParameterMapper(getFunctionParameters(this._type));\r\n        if (isFunction(parameterMapperFunc)) {\r\n            parameterMapperFunc(this._constructorParameterMapper);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    withProperties(propertyValueMapperFunc) {\r\n        if (this._resolvePropertyValues === true) {\r\n            throw new Error('Property values are already configured.');\r\n        }\r\n        this._resolvePropertyValues = true;\r\n        this._propertyValueMapper = new PropertyMapper();\r\n        if (isFunction(propertyValueMapperFunc)) {\r\n            propertyValueMapperFunc(this._propertyValueMapper);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    inSingletonScope() {\r\n        this._isInSingletonScope = true;\r\n    }\r\n\r\n    _resolve() {\r\n        if (this._isInSingletonScope && this._resolvedInstance) {\r\n            return this._resolvedInstance;\r\n        } else {\r\n            if (this._resolveWithConstructor === true) {\r\n                const constructorArguments = this._constructorParameterMapper._resolve();\r\n                this._resolvedInstance = new this._type(...constructorArguments);\r\n            } else {\r\n                this._resolvedInstance = new this._type();\r\n            }\r\n            if (this._resolvePropertyValues === true) {\r\n                this._propertyValueMapper._resolve()\r\n                    .forEach(([name, value]) => {\r\n                        this._resolvedInstance[name] = value;\r\n                    });\r\n            }\r\n            return this._resolvedInstance;\r\n        }\r\n    }\r\n}\r\n\r\nclass ParameterMapper {\r\n    constructor(parameterNames) {\r\n        this._parameterMap = new Map(\r\n            parameterNames\r\n                .map(param => [param, new ParameterDetails(param)])\r\n        );\r\n    }\r\n    param(name) {\r\n        if (!this._parameterMap.has(name)) {\r\n            throw new Error(`Parameter \"${name}\" was not detected.`);\r\n        }\r\n        return this._parameterMap.get(name);\r\n    }\r\n\r\n    _resolve() {\r\n        return [...this._parameterMap.values()].map(param => param._resolve());\r\n    }\r\n}\r\n\r\nclass PropertyMapper {\r\n    constructor() {\r\n        this._propertyMap = new Map();\r\n    }\r\n    property(name) {\r\n        if (!this._propertyMap.has(name)) {\r\n            this._propertyMap.set(name, new ParameterDetails(name));\r\n        }\r\n        return this._propertyMap.get(name);\r\n    }\r\n    _resolve() {\r\n        return [...this._propertyMap.entries()]\r\n            .map(([name, prop]) => [name, prop._resolve()]);\r\n    }\r\n}\r\n\r\nclass ParameterDetails {\r\n    constructor(parameterName) {\r\n        this._name = parameterName;\r\n\r\n        this._resolveAsValue = false;\r\n        this._valueToResolve = null;\r\n\r\n        this._resolveAsDependency = false;\r\n        this._registrationNameToResolve = null;\r\n        this._mappingNameToResolve = null;\r\n    }\r\n    asValue(valueToResolve) {\r\n        this._resolveAsValue = true;\r\n        this._valueToResolve = valueToResolve;\r\n    }\r\n    asDependency(registrationName, mappingName) {\r\n        this._resolveAsDependency = true;\r\n        this._registrationNameToResolve = registrationName;\r\n        this._mappingNameToResolve = mappingName;\r\n    }\r\n\r\n    _resolve() {\r\n        if (this._resolveAsValue) {\r\n            return this._valueToResolve;\r\n        } else if (this._resolveAsDependency) {\r\n            return DependencyContainer.resolve(this._registrationNameToResolve,\r\n                this._mappingNameToResolve);\r\n        }\r\n    }\r\n}\r\n\r\nfunction isFunction(func) {\r\n    return typeof func === 'function';\r\n}\r\n\r\nfunction getFunctionParameters(func) {\r\n    const paramExtract = func.toString()\r\n        .match(/\\s*function[^(]*\\(([^)]*)\\)/);\r\n    if (paramExtract && paramExtract.length === 2) {\r\n        return paramExtract[1]\r\n            .split(',')\r\n            .map(param => param.replace(/\\/\\/.*?[\\r\\n]|\\/\\*(?:.|[\\r\\n])*?\\*\\//g, '').trim());\r\n    } else {\r\n        throw new Error('Unable to fetch parameter details.');\r\n    }\r\n}\r\n\r\nexport { DependencyContainer };"]}